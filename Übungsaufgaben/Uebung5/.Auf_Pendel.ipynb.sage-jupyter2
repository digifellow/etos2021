{"backend_state":"running","connection_file":"/tmp/xdg-runtime-user/jupyter/kernel-a0b91a12-ec89-4959-98bf-ac38206f3d7e.json","kernel":"python3","kernel_error":"","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"trust":true,"type":"settings"}
{"cell_type":"markdown","id":"108229","input":"Um die Differentialgleichung\n$$ \\ddot{\\varphi} = - \\frac{g}{l} \\sin(\\varphi) $$\nzu lösen, wird das Zeitinterval $[0;t_{max}]$ in $N_I=10000$ gleichgroße Intervalle zerlegt. Dadurch entstehen diskrete Zeitpunkte $t_i$ mit $i=0, \\dots, N_I$ mit konstanten Abstand $\\Delta t = t_{max}/N_I$. Ziel ist dann ungefähre Werte der Auslenkung $\\varphi(t_i)$ und Winkelgeschwindigkeit $\\dot{\\varphi}(t_i)$ zu diesen Zeitpunkten zu berechnen.\n\nDafür kann die Definition der Ableitung für kleine Zeitpunkten $\\Delta t$ herangezogen werden:\n$$ \\dot{\\varphi}(t) \\approx \\frac{\\varphi(t+\\Delta t) - \\varphi(t)}{\\Delta t} $$\n\nSetzt man jetzt $t=t_i$ auf einen der diskreten Zeitpunkte, so ist $t_i + \\Delta t = t_{i+1}$ der nächste Zeitpunkt. Umstellen nach $\\varphi(t_{i+1})$ liefert:\n$$ \\dot{\\varphi}(t_i) \\approx \\frac{\\varphi(t_{i+1}) - \\varphi(t_i)}{\\Delta t} $$\n$$\\Rightarrow \\varphi(t_{i+1}) \\approx \\varphi(t_i)+ \\dot{\\varphi}(t_i) \\cdot \\Delta t$$\n\nDies entspricht der Bewegung bei konstanter Geschwindigkeit über das Interval $[t_i;t_{i+1}]$ hinweg.\n\nAnalog für $\\ddot{\\varphi}(t)$ :\n$$ \\Rightarrow \\dot{\\varphi}(t_{i+1}) = \\dot{\\varphi}(t_i) + \\ddot{\\varphi}(t_i) \\cdot \\Delta t $$\n\nDies entspricht der Bewegung bei konstanter Beschleunigung über das Interval $[t_i;t_{i+1}]$ hinweg.\n\n<div style=\"background-color:#f6f6f6;border:1px solid #707070;padding:0.5em 1em;box-sizing:border-box;\">\nZusammengefasst lassen sich aus den Werten $\\varphi(t_i), \\dot{\\varphi}(t_i)$ somit die Werte zum nächsten Zeitpunkt $\\varphi(t_{i+1})$, $\\dot{\\varphi}(t_{i+1})$ berechnen:\n\n    \n$$ \\ddot{\\varphi}(t_i) = -\\frac{g}{l} \\sin(\\varphi(t_i)) $$\n$$ \\dot{\\varphi}(t_{i+1}) = \\dot{\\varphi}(t_i) + \\ddot{\\varphi}(t_i) \\cdot \\Delta t $$\n$$ \\varphi(t_{i+1}) = \\varphi(t_i) + \\dot{\\varphi}(t_{i}) \\cdot \\Delta t $$\n</div>","pos":6,"type":"cell"}
{"cell_type":"markdown","id":"15af01","input":"<div class=\"alert alert-block alert-info\">\n<i class=\"fas fa-lightbulb\"></i> <b>Code Tipps:</b> \n<ul>\n<code>for</code>-Schleifen dienen dazu bei Wiederholungsanweisungen beschränkten Iterationen der Form „Führe A genau $n$-mal aus“ auszuführen. Die Syntax ist:\n\n```python\nfor i in list:\n    Anweisungen\n```\n    \n</div>\n    \n<div class=\"alert alert-block alert-danger\">\n<b>Vorsicht!</b> \n<ul>\n<p> Sie bekommen einen Laufzeitfehler der Form <code>IndexError: list assignment index out of range</code>, wenn ein Zugriff auf ein Element des Arrays außerhalb der Feldgrenzen stattfindet. Beachten Sie, dass der Index eines Arrays immer eine ganze Zahl sein muss. Sie erhalten einen Syntaxfehler, falls die Indexposition oder die Länge des Feldes eine Gleitkommazahl ist.\n </p>     \n</div>","pos":1.6875,"type":"cell"}
{"cell_type":"markdown","id":"48499f","input":"___\n### `for`-Schleife\n\nEine `for`-Schleife kann man in folgender Form deklarieren:\n```python\nfor i in list:\n    Anweisungen\n```\n\nManchmal sind Anweisungen mehrfach zu wiederholen. Das Kopieren unzähliger gleicher Anweisungen ist ineffizient und unpraktikabel, da die Anzahl der Wiederholungen oftmals zu groß ist. Eine `for`-Schleife kann die gleiche Aufgabe so oft ausführen, wie wir sie eingegeben haben. \n\nAls Beispiel werden wir die Winkelgeschwindigkeit $\\omega$ numerisch berechnen\n\n$$\\omega = \\frac{\\text{d}\\varphi}{\\text{d}t} \\approx \\frac{\\Delta \\varphi}{\\Delta t}$$\n\n\n\n1. Bereiten Sie die Listen oder Arrays von Daten vor, die Sie iterieren möchten.\n\n```python\nt = np.array([0, 0.011, 0.022, 0.033, 0.044,0.055, 0.066, 0.077, 0.088, 0.1])    # in s\nphi = np.array([ 0, 11.851, 20.740, 26.666, 29.629, 29.629, 26.666, 20.740, 11.851, 0])  # -\n```\n\n2. Wählen Sie einen geeigneten *Iterator* `i` (Sie können anderen Variablennamen verwenden); in diesem Fall werden wir *die Länge von `t`* verwenden, weil wir alle Elemente von `t` und `F` iterieren wollen (sie haben die gleiche Länge).\n\n```python\nfor i in range(0,len(t)-1):\n```\n\nDie `range`-Funktion liefert Listen, die arithmetischen Aufzählungen entsprechen, von Anfangswert `0` bist Endwert `len(t)-1` (Vergessen Sie nicht, dass Python-Listen und -Arrays mit dem Index 0 beginnen!) \n\n3. Klicken Sie auf <code>ENTER ↵</code> und schreiben Sie die Anweisungen Ihrer `for`-Schleife, Sie sollten am Anfang eine Einrückung durch <code>TAB</code> erhalten. Die Anweisungen für diese Beispiel sind:   \n    i. Berechnung der Winkelgeschwindigkeit \n    \n    $$\\omega_i = \\dfrac{\\varphi_{i+1}-\\varphi_{i}}{t_{i+1}-t_{i}}$$  \n    \n```python\nfor i in range(0,len(t)-1):\n    omega_i = (phi[i+1] - phi[i])/(t[i+1]-t[i]) \n```\nDie Variable `omega_i` wird sich jedes Mal ändern, wenn der Iterator dies tut.\n\n4. Was als nächstes mit der iterierten Variable `omega_i` zu tun ist, hängt von Ihrer Aufgabe ab. Sie können die Ergebnisse einfach ausdrucken, oder, was häufiger gemacht wird, Sie speichern die bearbeitete Variable in einer Liste wie folgt:\n\n```python\nomega = []\nfor i in range(0,len(t)-1):\n    omega_i = (phi[i+1] - phi[i])/(t[i+1]-t[i])\n    omega.append(omega_i)\n```\n\nSie sollen vor der Deklaration der `for`-Schleife eine leere Liste definieren (hier `omega = []`), jeder generierte `omega_i`-Wert wird in der Liste `omega` gespeichert, dies geschieht mit Hilfe der `append`-Funktion.","pos":1,"type":"cell"}
{"cell_type":"markdown","id":"6921f9","input":"6. Plotten Sie die Zeit $t$ gegen die Auslenkung $\\varphi(t)$. Sie können dafür die soeben mit Werten gefüllten arrays `t, phi` verwenden.","pos":19,"type":"cell"}
{"cell_type":"markdown","id":"8704b0","input":"3. Nun gilt es rekursiv die Werte zu allen Zeiten zu berechnen. Diese sollen als drei numpy arrays `t, phi, phi_punkt` gespeichert werden. Dabei sind die Elemente `t[i], phi[i], phi_punkt[i]` die Werte $t_i,\\, \\varphi(t_i), \\dot{\\varphi}(t_i)$ für $i=0,\\dots,N_I$. Erzeugen Sie drei leere numpy arrays (mit 0ern gefüllt) der richtigen Länge.","pos":10,"type":"cell"}
{"cell_type":"markdown","id":"87424a","input":"4. Weisen Sie den ersten Einträgen der arrays die jeweiligen Startwerte zu. So ist unter anderem $t_0 = 0.0$, d.h. `t[0] = 0.0`.","pos":13,"type":"cell"}
{"cell_type":"markdown","id":"a7dd25","input":"<div style= \"color: black;background-color: rgba(0,177,172, 0.1) ;margin: 10 px auto; padding: 10px; border-radius: 10px\">\n<p style=\"font-size:12pt; text-align:center; color:   black;background-color: rgba(0,177,172, 0.1) ;margin: 10 px auto; padding: 10px; border-radius: 10px\" id=\"3\"><b>  Aufgabe 3 </b>  </p> \n\nDie Bewegung eines Fadenpendel ist durch die folgende Differentialgleichung definiert: $$ \\ddot{\\varphi} = - \\frac{g}{l} \\sin(\\varphi) $$ \n\nDiese Aufgabe beschäftigt sich wie das Fandenpendel <b>ohne</b> Kleinwinkelnäherung <b>numerisch</b>  gelöst werden kann. Differentialgleichungen sind von großer Bedeutung in der Physik und werden im Verlauf Ihres weiteren Studiums häufig auftreten. Nicht immer ist eine exakte Lösung per Hand möglich, so zum Beispiel auch beim Fadenpendel. Deshalb präsentieren wir hier numerischen Methoden. Manchmal wurde die <b>Kleinwinkelnäherung</b>  benutzt: $\\sin(\\varphi) \\approx \\varphi$ für kleine $\\varphi$. Mit dieser ist die Differentialgleichung dann identisch zu der des Federpendels:\n$$ \\ddot{\\varphi} = - \\frac{g}{l} \\varphi $$\nZur Startzeit $t=0$ wird das Pendel mit einer Auslenkung $\\varphi_0=45^\\circ$ losgelassen, hat also Winkelgeschwindigkeit $\\dot{\\varphi}(0)=0$; siese Werte entsprechen den <b>Anfangswerten</b> der Differentialgleichung.. Das reibungslose Schwingen des Fadenpendels soll dann für das Interval bis $t_\\text{max}=10~s$ berechnet werden.\n    \n<img src=\"static/fadenpendel_animation2.gif\" style=\"float: center;height: 27em;\">\n\n<img src=\"static/PenduloTmg.gif\" style=\"float: center;height: 27em;\">\n\n</div>","pos":2,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"c1778f","input":"5. Da die Werte $\\varphi(t_0), \\dot{\\varphi}(t_0)$ bekannt sind, können nun die Werte zur Zeit $t_1$ berechnet werden. Danach kann man die Werte zur Zeit $t_2$ berechnen, dann zur Zeit $t_3$, und so weiter. Diese 10000 Schritte von Hand zu programmieren ist weder machbar noch lesbar, daher wird eine `for`-Schleife verwendet, um diesen iterativen Vorgang zu automatisieren. Dafür stehen bereits die Funktionen `next_phi` und `next_phi_dot` zur Verfügung. Berechnen und weisen Sie die Werte für `t[i+1]` ($=t_{i+1}$), `phi[i+1]` ($=\\varphi(t_{i+1})$) und `phi_dot[i+1]` ($=\\dot{\\varphi}(t_{i+1})$) zu. ","pos":16,"type":"cell"}
{"cell_type":"markdown","id":"f3f0ea","input":"2. Für den Ausdruck $\\ddot{\\varphi}(t_i)$ kann die soeben programmierte Funktion `phi_punktpunkt` verwendet werden, es wird dann nur die Auslenkung `phi=`$\\varphi(t_i)$ benötigt. Erstellen Sie eine Funktion `naechstes_phi` die aus den Werten $\\varphi(t_i)$ (`phi_i`) und $\\dot{\\varphi}(t_i)$ (`phi_dot_i`) den Wert $\\varphi(t_{i+1})$ berechnet. Eine ähnliche Funktion `naechstes_phi_punkt` die $\\dot{\\varphi}(t_{i+1})$ berechnet ist bereits vorgeben.","pos":7,"type":"cell"}
{"cell_type":"markdown","id":"f4efd5","input":"**Vorgehensweise**       \n1. Programmieren Sie eine Funktion `phi_punktpunkt` welche den Winkel $\\varphi$ (`phi`) in Bogenmaß als Argument nimmt, und die Beschleunigung $\\ddot{\\varphi}$ (Bogenmaß pro $s^2$) zurückgibt. Nehmen Sie an:  \n    - die Erdbeschleunigung ist $g=9,81~m/s^2$\n    - die Länge des Pendels ist $l=1~m$","pos":3,"type":"cell"}
{"end":1623651937197,"exec_count":3,"id":"76293e","input":"import numpy as np\n\nt = np.array([0, 0.011, 0.022, 0.033, 0.044,0.055, 0.066, 0.077, 0.088, 0.1])    # in s\nphi = np.array([ 0, 11.851, 20.740, 26.666, 29.629, 29.629, 26.666, 20.740, 11.851, 0])  # -\n\nomega = []\nfor i in range(0,len(t)-1):\n    omega_i = (phi[i+1] - phi[i])/(t[i+1]-t[i])\n    omega.append(omega_i)\n\nomega","kernel":"python3","output":{"0":{"data":{"text/plain":"[1077.3636363636365,\n 808.0909090909089,\n 538.7272727272727,\n 269.36363636363654,\n 0.0,\n -269.3636363636364,\n -538.7272727272731,\n -808.0909090909091,\n -987.5833333333326]"},"exec_count":3}},"pos":1.5,"start":1623651937192,"state":"done","type":"cell"}
{"end":1623651960777,"exec_count":4,"id":"307ba3","input":"import numpy as np\n\nt = np.array([0, 0.011, 0.022, 0.033, 0.044,0.055, 0.066, 0.077, 0.088, 0.1])    # in s\nphi = np.array([ 0, 11.851, 20.740, 26.666, 29.629, 29.629, 26.666, 20.740, 11.851, 0])  # -\n\nomega = np.zeros([len(t)-1])\nfor i in range(0,len(t)-1):\n    omega[i] = (phi[i+1] - phi[i])/(t[i+1]-t[i])\n\nomega","kernel":"python3","output":{"0":{"data":{"text/plain":"array([1077.36363636,  808.09090909,  538.72727273,  269.36363636,\n          0.        , -269.36363636, -538.72727273, -808.09090909,\n       -987.58333333])"},"exec_count":4}},"pos":1.625,"start":1623651960770,"state":"done","type":"cell"}
{"id":"082f52","input":"#development\n%load_ext extension_notebook_splitter","pos":0,"type":"cell"}
{"id":"091cd4","input":"%%task\n# Test des bisherigen Programms\nimport matplotlib.pyplot as plt\n\nplt.plot()\nplt.xlabel(\"\")\nplt.ylabel(\"\")\nplt.show()","pos":21,"type":"cell"}
{"id":"52e12a","input":"%%solution\nN_I = 10000\nDt = t_max / N_I # Δ𝑡 in s\n\n# vervollständigen Sie:\ndef naechstes_phi(phi_i, phi_punkt_i):\n    return phi_i + phi_punkt_i * Dt\n\n# bereits vorgegeben:\ndef naechstes_phi_punkt(phi_i, phi_punkt_i):\n    return phi_punkt_i + phi_punktpunkt(phi_i) * Dt","pos":8,"type":"cell"}
{"id":"82f1c9","input":"%%solution\nimport numpy as np\n\ng = 9.81 # m/s^2\nl = 1.0  # m\nt_max = 10.0 # s\nphi_0 = np.pi / 4 # Bogenmaß\n\n# Funktion definieren\ndef phi_punktpunkt(phi):\n    return -g/l * np.sin(phi)","pos":4,"type":"cell"}
{"id":"8c1194","input":"%%task\n# Aufgabenteil : Startwerte\nt[0] = 0.0\nphi[0] = \nphi_punkt[0] = ","pos":15,"type":"cell"}
{"id":"8f71cd","input":"%%task\nimport numpy as np\n\ng = 9.81 # m/s^2\nl = 1.0  # m\nt_max = 10.0 # s\nphi_0 = np.pi / 4 # Bogenmaß\n\n# Funktion definieren\ndef phi_punktpunkt(phi):","pos":5,"type":"cell"}
{"id":"9cd6a3","input":"%%solution\n# Test des bisherigen Programms\nimport matplotlib.pyplot as plt\n\nplt.plot(t, phi)\nplt.xlabel(\"t in $s$\")\nplt.ylabel(r\"$\\varphi$ in radians\")\nplt.show()","pos":20,"type":"cell"}
{"id":"c4d1d2","input":"%%solution\n# Aufgabenteil c) : Erzeugen der Arrays\nt = np.zeros(N_I+1)\nphi = np.zeros(N_I+1)\nphi_punkt = np.zeros(N_I+1)","pos":11,"type":"cell"}
{"id":"c9b2f8","input":"%%task\n# Aufgabenteil : Vervollständigen Sie die folgende Zeile\nfor i in range( , ):\n    # Aufgabenteil : Rekursionsformeln für t, phi, phi_dot\n    t[i+1] = t[i] + Dt\n    phi[i+1] = \n    phi_punkt[i+1] = ","pos":18,"type":"cell"}
{"id":"cb7609","input":"%%solution\n# Aufgabenteil : Startwerte\nt[0] = 0.0\nphi[0] = phi_0\nphi_punkt[0] = 0.0","pos":14,"type":"cell"}
{"id":"cd1c34","input":"%%solution\n# Aufgabenteil : Vervollständigen Sie die folgende Zeile\nfor i in range(0, N_I):\n    # Aufgabenteil : Rekursionsformeln für t, phi, phi_dot\n    t[i+1] = t[i] + Dt\n    phi[i+1] = naechstes_phi(phi[i], phi_punkt[i])\n    phi_punkt[i+1] = naechstes_phi_punkt(phi[i], phi_punkt[i])","pos":17,"type":"cell"}
{"id":"f99b91","input":"%%task\nN_I = 10000\nDt = t_max / N_I # Δ𝑡 in s\n\n# vervollständigen Sie:\ndef naechstes_phi(phi_i, phi_punkt_i):\n    return \n\n# bereits vorgegeben:\ndef naechstes_phi_punkt(phi_i, phi_punkt_i):\n    return ","pos":9,"type":"cell"}
{"id":"fcdf95","input":"%%task\n# Aufgabenteil c) : Erzeugen der Arrays\nt = \nphi = \nphi_punkt = ","pos":12,"type":"cell"}
{"id":0,"time":1623652084132,"type":"user"}
{"last_load":1623650010269,"type":"file"}