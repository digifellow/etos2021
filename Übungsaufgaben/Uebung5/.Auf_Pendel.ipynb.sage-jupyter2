{"backend_state":"running","connection_file":"/tmp/xdg-runtime-user/jupyter/kernel-a0b91a12-ec89-4959-98bf-ac38206f3d7e.json","kernel":"python3","kernel_error":"","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"trust":true,"type":"settings"}
{"cell_type":"markdown","id":"108229","input":"Um die Differentialgleichung\n$$ \\ddot{\\varphi} = - \\frac{g}{l} \\sin(\\varphi) $$\nzu l√∂sen, wird das Zeitinterval $[0;t_{max}]$ in $N_I=10000$ gleichgro√üe Intervalle zerlegt. Dadurch entstehen diskrete Zeitpunkte $t_i$ mit $i=0, \\dots, N_I$ mit konstanten Abstand $\\Delta t = t_{max}/N_I$. Ziel ist dann ungef√§hre Werte der Auslenkung $\\varphi(t_i)$ und Winkelgeschwindigkeit $\\dot{\\varphi}(t_i)$ zu diesen Zeitpunkten zu berechnen.\n\nDaf√ºr kann die Definition der Ableitung f√ºr kleine Zeitpunkten $\\Delta t$ herangezogen werden:\n$$ \\dot{\\varphi}(t) \\approx \\frac{\\varphi(t+\\Delta t) - \\varphi(t)}{\\Delta t} $$\n\nSetzt man jetzt $t=t_i$ auf einen der diskreten Zeitpunkte, so ist $t_i + \\Delta t = t_{i+1}$ der n√§chste Zeitpunkt. Umstellen nach $\\varphi(t_{i+1})$ liefert:\n$$ \\dot{\\varphi}(t_i) \\approx \\frac{\\varphi(t_{i+1}) - \\varphi(t_i)}{\\Delta t} $$\n$$\\Rightarrow \\varphi(t_{i+1}) \\approx \\varphi(t_i)+ \\dot{\\varphi}(t_i) \\cdot \\Delta t$$\n\nDies entspricht der Bewegung bei konstanter Geschwindigkeit √ºber das Interval $[t_i;t_{i+1}]$ hinweg.\n\nAnalog f√ºr $\\ddot{\\varphi}(t)$ :\n$$ \\Rightarrow \\dot{\\varphi}(t_{i+1}) = \\dot{\\varphi}(t_i) + \\ddot{\\varphi}(t_i) \\cdot \\Delta t $$\n\nDies entspricht der Bewegung bei konstanter Beschleunigung √ºber das Interval $[t_i;t_{i+1}]$ hinweg.\n\n<div style=\"background-color:#f6f6f6;border:1px solid #707070;padding:0.5em 1em;box-sizing:border-box;\">\nZusammengefasst lassen sich aus den Werten $\\varphi(t_i), \\dot{\\varphi}(t_i)$ somit die Werte zum n√§chsten Zeitpunkt $\\varphi(t_{i+1})$, $\\dot{\\varphi}(t_{i+1})$ berechnen:\n\n    \n$$ \\ddot{\\varphi}(t_i) = -\\frac{g}{l} \\sin(\\varphi(t_i)) $$\n$$ \\dot{\\varphi}(t_{i+1}) = \\dot{\\varphi}(t_i) + \\ddot{\\varphi}(t_i) \\cdot \\Delta t $$\n$$ \\varphi(t_{i+1}) = \\varphi(t_i) + \\dot{\\varphi}(t_{i}) \\cdot \\Delta t $$\n</div>","pos":6,"type":"cell"}
{"cell_type":"markdown","id":"15af01","input":"<div class=\"alert alert-block alert-info\">\n<i class=\"fas fa-lightbulb\"></i> <b>Code Tipps:</b> \n<ul>\n<code>for</code>-Schleifen dienen dazu bei Wiederholungsanweisungen beschr√§nkten Iterationen der Form ‚ÄûF√ºhre A genau $n$-mal aus‚Äú auszuf√ºhren. Die Syntax ist:\n\n```python\nfor i in list:\n    Anweisungen\n```\n    \n</div>\n    \n<div class=\"alert alert-block alert-danger\">\n<b>Vorsicht!</b> \n<ul>\n<p> Sie bekommen einen Laufzeitfehler der Form <code>IndexError: list assignment index out of range</code>, wenn ein Zugriff auf ein Element des Arrays au√üerhalb der Feldgrenzen stattfindet. Beachten Sie, dass der Index eines Arrays immer eine ganze Zahl sein muss. Sie erhalten einen Syntaxfehler, falls die Indexposition oder die L√§nge des Feldes eine Gleitkommazahl ist.\n </p>     \n</div>","pos":1.6875,"type":"cell"}
{"cell_type":"markdown","id":"48499f","input":"___\n### `for`-Schleife\n\nEine `for`-Schleife kann man in folgender Form deklarieren:\n```python\nfor i in list:\n    Anweisungen\n```\n\nManchmal sind Anweisungen mehrfach zu wiederholen. Das Kopieren unz√§hliger gleicher Anweisungen ist ineffizient und unpraktikabel, da die Anzahl der Wiederholungen oftmals zu gro√ü ist. Eine `for`-Schleife kann die gleiche Aufgabe so oft ausf√ºhren, wie wir sie eingegeben haben. \n\nAls Beispiel werden wir die Winkelgeschwindigkeit $\\omega$ numerisch berechnen\n\n$$\\omega = \\frac{\\text{d}\\varphi}{\\text{d}t} \\approx \\frac{\\Delta \\varphi}{\\Delta t}$$\n\n\n\n1. Bereiten Sie die Listen oder Arrays von Daten vor, die Sie iterieren m√∂chten.\n\n```python\nt = np.array([0, 0.011, 0.022, 0.033, 0.044,0.055, 0.066, 0.077, 0.088, 0.1])    # in s\nphi = np.array([ 0, 11.851, 20.740, 26.666, 29.629, 29.629, 26.666, 20.740, 11.851, 0])  # -\n```\n\n2. W√§hlen Sie einen geeigneten *Iterator* `i` (Sie k√∂nnen anderen Variablennamen verwenden); in diesem Fall werden wir *die L√§nge von `t`* verwenden, weil wir alle Elemente von `t` und `F` iterieren wollen (sie haben die gleiche L√§nge).\n\n```python\nfor i in range(0,len(t)-1):\n```\n\nDie `range`-Funktion liefert Listen, die arithmetischen Aufz√§hlungen entsprechen, von Anfangswert `0` bist Endwert `len(t)-1` (Vergessen Sie nicht, dass Python-Listen und -Arrays mit dem Index 0 beginnen!) \n\n3. Klicken Sie auf <code>ENTER ‚Üµ</code> und schreiben Sie die Anweisungen Ihrer `for`-Schleife, Sie sollten am Anfang eine Einr√ºckung durch <code>TAB</code> erhalten. Die Anweisungen f√ºr diese Beispiel sind:   \n    i. Berechnung der Winkelgeschwindigkeit \n    \n    $$\\omega_i = \\dfrac{\\varphi_{i+1}-\\varphi_{i}}{t_{i+1}-t_{i}}$$  \n    \n```python\nfor i in range(0,len(t)-1):\n    omega_i = (phi[i+1] - phi[i])/(t[i+1]-t[i]) \n```\nDie Variable `omega_i` wird sich jedes Mal √§ndern, wenn der Iterator dies tut.\n\n4. Was als n√§chstes mit der iterierten Variable `omega_i` zu tun ist, h√§ngt von Ihrer Aufgabe ab. Sie k√∂nnen die Ergebnisse einfach ausdrucken, oder, was h√§ufiger gemacht wird, Sie speichern die bearbeitete Variable in einer Liste wie folgt:\n\n```python\nomega = []\nfor i in range(0,len(t)-1):\n    omega_i = (phi[i+1] - phi[i])/(t[i+1]-t[i])\n    omega.append(omega_i)\n```\n\nSie sollen vor der Deklaration der `for`-Schleife eine leere Liste definieren (hier `omega = []`), jeder generierte `omega_i`-Wert wird in der Liste `omega` gespeichert, dies geschieht mit Hilfe der `append`-Funktion.","pos":1,"type":"cell"}
{"cell_type":"markdown","id":"6921f9","input":"6. Plotten Sie die Zeit $t$ gegen die Auslenkung $\\varphi(t)$. Sie k√∂nnen daf√ºr die soeben mit Werten gef√ºllten arrays `t, phi` verwenden.","pos":19,"type":"cell"}
{"cell_type":"markdown","id":"8704b0","input":"3. Nun gilt es rekursiv die Werte zu allen Zeiten zu berechnen. Diese sollen als drei numpy arrays `t, phi, phi_punkt` gespeichert werden. Dabei sind die Elemente `t[i], phi[i], phi_punkt[i]` die Werte $t_i,\\, \\varphi(t_i), \\dot{\\varphi}(t_i)$ f√ºr $i=0,\\dots,N_I$. Erzeugen Sie drei leere numpy arrays (mit 0ern gef√ºllt) der richtigen L√§nge.","pos":10,"type":"cell"}
{"cell_type":"markdown","id":"87424a","input":"4. Weisen Sie den ersten Eintr√§gen der arrays die jeweiligen Startwerte zu. So ist unter anderem $t_0 = 0.0$, d.h. `t[0] = 0.0`.","pos":13,"type":"cell"}
{"cell_type":"markdown","id":"a7dd25","input":"<div style= \"color: black;background-color: rgba(0,177,172, 0.1) ;margin: 10 px auto; padding: 10px; border-radius: 10px\">\n<p style=\"font-size:12pt; text-align:center; color:   black;background-color: rgba(0,177,172, 0.1) ;margin: 10 px auto; padding: 10px; border-radius: 10px\" id=\"3\"><b>  Aufgabe 3 </b>  </p> \n\nDie Bewegung eines Fadenpendel ist durch die folgende Differentialgleichung definiert: $$ \\ddot{\\varphi} = - \\frac{g}{l} \\sin(\\varphi) $$ \n\nDiese Aufgabe besch√§ftigt sich wie das Fandenpendel <b>ohne</b> Kleinwinkeln√§herung <b>numerisch</b>  gel√∂st werden kann. Differentialgleichungen sind von gro√üer Bedeutung in der Physik und werden im Verlauf Ihres weiteren Studiums h√§ufig auftreten. Nicht immer ist eine exakte L√∂sung per Hand m√∂glich, so zum Beispiel auch beim Fadenpendel. Deshalb pr√§sentieren wir hier numerischen Methoden. Manchmal wurde die <b>Kleinwinkeln√§herung</b>  benutzt: $\\sin(\\varphi) \\approx \\varphi$ f√ºr kleine $\\varphi$. Mit dieser ist die Differentialgleichung dann identisch zu der des Federpendels:\n$$ \\ddot{\\varphi} = - \\frac{g}{l} \\varphi $$\nZur Startzeit $t=0$ wird das Pendel mit einer Auslenkung $\\varphi_0=45^\\circ$ losgelassen, hat also Winkelgeschwindigkeit $\\dot{\\varphi}(0)=0$; siese Werte entsprechen den <b>Anfangswerten</b> der Differentialgleichung.. Das reibungslose Schwingen des Fadenpendels soll dann f√ºr das Interval bis $t_\\text{max}=10~s$ berechnet werden.\n    \n<img src=\"static/fadenpendel_animation2.gif\" style=\"float: center;height: 27em;\">\n\n<img src=\"static/PenduloTmg.gif\" style=\"float: center;height: 27em;\">\n\n</div>","pos":2,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"c1778f","input":"5. Da die Werte $\\varphi(t_0), \\dot{\\varphi}(t_0)$ bekannt sind, k√∂nnen nun die Werte zur Zeit $t_1$ berechnet werden. Danach kann man die Werte zur Zeit $t_2$ berechnen, dann zur Zeit $t_3$, und so weiter. Diese 10000 Schritte von Hand zu programmieren ist weder machbar noch lesbar, daher wird eine `for`-Schleife verwendet, um diesen iterativen Vorgang zu automatisieren. Daf√ºr stehen bereits die Funktionen `next_phi` und `next_phi_dot` zur Verf√ºgung. Berechnen und weisen Sie die Werte f√ºr `t[i+1]` ($=t_{i+1}$), `phi[i+1]` ($=\\varphi(t_{i+1})$) und `phi_dot[i+1]` ($=\\dot{\\varphi}(t_{i+1})$) zu. ","pos":16,"type":"cell"}
{"cell_type":"markdown","id":"f3f0ea","input":"2. F√ºr den Ausdruck $\\ddot{\\varphi}(t_i)$ kann die soeben programmierte Funktion `phi_punktpunkt` verwendet werden, es wird dann nur die Auslenkung `phi=`$\\varphi(t_i)$ ben√∂tigt. Erstellen Sie eine Funktion `naechstes_phi` die aus den Werten $\\varphi(t_i)$ (`phi_i`) und $\\dot{\\varphi}(t_i)$ (`phi_dot_i`) den Wert $\\varphi(t_{i+1})$ berechnet. Eine √§hnliche Funktion `naechstes_phi_punkt` die $\\dot{\\varphi}(t_{i+1})$ berechnet ist bereits vorgeben.","pos":7,"type":"cell"}
{"cell_type":"markdown","id":"f4efd5","input":"**Vorgehensweise**       \n1. Programmieren Sie eine Funktion `phi_punktpunkt` welche den Winkel $\\varphi$ (`phi`) in Bogenma√ü als Argument nimmt, und die Beschleunigung $\\ddot{\\varphi}$ (Bogenma√ü pro $s^2$) zur√ºckgibt. Nehmen Sie an:  \n    - die Erdbeschleunigung ist $g=9,81~m/s^2$\n    - die L√§nge des Pendels ist $l=1~m$","pos":3,"type":"cell"}
{"end":1623651937197,"exec_count":3,"id":"76293e","input":"import numpy as np\n\nt = np.array([0, 0.011, 0.022, 0.033, 0.044,0.055, 0.066, 0.077, 0.088, 0.1])    # in s\nphi = np.array([ 0, 11.851, 20.740, 26.666, 29.629, 29.629, 26.666, 20.740, 11.851, 0])  # -\n\nomega = []\nfor i in range(0,len(t)-1):\n    omega_i = (phi[i+1] - phi[i])/(t[i+1]-t[i])\n    omega.append(omega_i)\n\nomega","kernel":"python3","output":{"0":{"data":{"text/plain":"[1077.3636363636365,\n 808.0909090909089,\n 538.7272727272727,\n 269.36363636363654,\n 0.0,\n -269.3636363636364,\n -538.7272727272731,\n -808.0909090909091,\n -987.5833333333326]"},"exec_count":3}},"pos":1.5,"start":1623651937192,"state":"done","type":"cell"}
{"end":1623651960777,"exec_count":4,"id":"307ba3","input":"import numpy as np\n\nt = np.array([0, 0.011, 0.022, 0.033, 0.044,0.055, 0.066, 0.077, 0.088, 0.1])    # in s\nphi = np.array([ 0, 11.851, 20.740, 26.666, 29.629, 29.629, 26.666, 20.740, 11.851, 0])  # -\n\nomega = np.zeros([len(t)-1])\nfor i in range(0,len(t)-1):\n    omega[i] = (phi[i+1] - phi[i])/(t[i+1]-t[i])\n\nomega","kernel":"python3","output":{"0":{"data":{"text/plain":"array([1077.36363636,  808.09090909,  538.72727273,  269.36363636,\n          0.        , -269.36363636, -538.72727273, -808.09090909,\n       -987.58333333])"},"exec_count":4}},"pos":1.625,"start":1623651960770,"state":"done","type":"cell"}
{"id":"082f52","input":"#development\n%load_ext extension_notebook_splitter","pos":0,"type":"cell"}
{"id":"091cd4","input":"%%task\n# Test des bisherigen Programms\nimport matplotlib.pyplot as plt\n\nplt.plot()\nplt.xlabel(\"\")\nplt.ylabel(\"\")\nplt.show()","pos":21,"type":"cell"}
{"id":"52e12a","input":"%%solution\nN_I = 10000\nDt = t_max / N_I # Œîùë° in s\n\n# vervollst√§ndigen Sie:\ndef naechstes_phi(phi_i, phi_punkt_i):\n    return phi_i + phi_punkt_i * Dt\n\n# bereits vorgegeben:\ndef naechstes_phi_punkt(phi_i, phi_punkt_i):\n    return phi_punkt_i + phi_punktpunkt(phi_i) * Dt","pos":8,"type":"cell"}
{"id":"82f1c9","input":"%%solution\nimport numpy as np\n\ng = 9.81 # m/s^2\nl = 1.0  # m\nt_max = 10.0 # s\nphi_0 = np.pi / 4 # Bogenma√ü\n\n# Funktion definieren\ndef phi_punktpunkt(phi):\n    return -g/l * np.sin(phi)","pos":4,"type":"cell"}
{"id":"8c1194","input":"%%task\n# Aufgabenteil : Startwerte\nt[0] = 0.0\nphi[0] = \nphi_punkt[0] = ","pos":15,"type":"cell"}
{"id":"8f71cd","input":"%%task\nimport numpy as np\n\ng = 9.81 # m/s^2\nl = 1.0  # m\nt_max = 10.0 # s\nphi_0 = np.pi / 4 # Bogenma√ü\n\n# Funktion definieren\ndef phi_punktpunkt(phi):","pos":5,"type":"cell"}
{"id":"9cd6a3","input":"%%solution\n# Test des bisherigen Programms\nimport matplotlib.pyplot as plt\n\nplt.plot(t, phi)\nplt.xlabel(\"t in $s$\")\nplt.ylabel(r\"$\\varphi$ in radians\")\nplt.show()","pos":20,"type":"cell"}
{"id":"c4d1d2","input":"%%solution\n# Aufgabenteil c) : Erzeugen der Arrays\nt = np.zeros(N_I+1)\nphi = np.zeros(N_I+1)\nphi_punkt = np.zeros(N_I+1)","pos":11,"type":"cell"}
{"id":"c9b2f8","input":"%%task\n# Aufgabenteil : Vervollst√§ndigen Sie die folgende Zeile\nfor i in range( , ):\n    # Aufgabenteil : Rekursionsformeln f√ºr t, phi, phi_dot\n    t[i+1] = t[i] + Dt\n    phi[i+1] = \n    phi_punkt[i+1] = ","pos":18,"type":"cell"}
{"id":"cb7609","input":"%%solution\n# Aufgabenteil : Startwerte\nt[0] = 0.0\nphi[0] = phi_0\nphi_punkt[0] = 0.0","pos":14,"type":"cell"}
{"id":"cd1c34","input":"%%solution\n# Aufgabenteil : Vervollst√§ndigen Sie die folgende Zeile\nfor i in range(0, N_I):\n    # Aufgabenteil : Rekursionsformeln f√ºr t, phi, phi_dot\n    t[i+1] = t[i] + Dt\n    phi[i+1] = naechstes_phi(phi[i], phi_punkt[i])\n    phi_punkt[i+1] = naechstes_phi_punkt(phi[i], phi_punkt[i])","pos":17,"type":"cell"}
{"id":"f99b91","input":"%%task\nN_I = 10000\nDt = t_max / N_I # Œîùë° in s\n\n# vervollst√§ndigen Sie:\ndef naechstes_phi(phi_i, phi_punkt_i):\n    return \n\n# bereits vorgegeben:\ndef naechstes_phi_punkt(phi_i, phi_punkt_i):\n    return ","pos":9,"type":"cell"}
{"id":"fcdf95","input":"%%task\n# Aufgabenteil c) : Erzeugen der Arrays\nt = \nphi = \nphi_punkt = ","pos":12,"type":"cell"}
{"id":0,"time":1623652084132,"type":"user"}
{"last_load":1623650010269,"type":"file"}